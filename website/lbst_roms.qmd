---
title: "Leatherback ROMS model"
toc: false
editor: 
  markdown: 
    wrap: 72
execute:
  echo: false
---

The most recent map products from the model are shown below, in addition
to an interactive map of the latest prediction.

```{r}
#| label: check-roms
#| warning: false
#| include: false

source("utils.R")

# Set today's date
get_date <- Sys.Date()

# Define dates of interest (related to 4-day lag from ROMS server)
dates <- get_date - 0:5

# ROMS status check
status <- sapply(dates, \(x) check_roms(x)) |> 
  any()

# Create badge based on result of ROMS status check
badge <- ifelse(status,
                "[![Static Badge](https://img.shields.io/badge/Status-Running-brightgreen?style=flat)](https://oceanmodeling.ucsc.edu/ccsnrt/)",
                "[![Static Badge](https://img.shields.io/badge/Status-Down-red?style=flat)](https://oceanmodeling.ucsc.edu/ccsnrt/)"
)

# If ROMS down, how long?
if (status == FALSE) {
  dates1 <- get_date
  status1 <- FALSE
  
  while (status1 == FALSE) {
    status1 <- check_roms(dates1 - 1)
    
    if (status1 == TRUE) {
      days_down <- as.numeric(get_date - dates1)
      break
    } else {
      dates1 <- dates1 - 1
    }
    
  }
  
}

```

**Status of environmental products from ROMS:** `r paste0(badge)`

[ROMS THREDDS server](https://oceanmodeling.ucsc.edu/thredds/dodsC/ccsra_2016a_phys_agg_zlevs/fmrc/CCSRA_2016a_Phys_ROMS_z-level_(depth)_Aggregation_best.ncd.html)

[*`r if (status == FALSE) paste("ROMS has been down for", days_down, "days")`*]{style="color: red;"}

## Latest Map Products

```{r}
library(bslib)
library(htmltools)

bs_theme_dependencies(bs_theme(preset = "bootstrap")) |>
  lapply(function(x) {
    if (x$name == "bootstrap") {
      x$name <- "bootstrap-from-bslib"
    }
    x
  }) |>
  htmltools::tagList()


navset_card_tab(
  nav_panel(title = "Latest", img(src = "https://github.com/joshcullen/CEG_operationalization/blob/main/model_prediction/ROMS/img/leatherbackTurtle_2024-11-24.png?raw=true", width = "50%")),
  nav_panel(title = "Latest - 1", img(src = "https://github.com/joshcullen/CEG_operationalization/blob/main/model_prediction/ROMS/img/leatherbackTurtle_2024-11-08.png?raw=true", width = "50%")),
  nav_panel(title = "Latest - 2", p("Add content"))
)
```

## Interactive Map

This example shows both model predictions and environmental covariates used to estimate the models. Change the date and selected variable to explore these relationships in more detail.

```{=html}
<iframe width="900" height="650" src="https://joshcullen.shinyapps.io/leatherback_roms_model/"></iframe>
```


:::{.content-hidden}
```{r}
#| column: body

library(leaflet)
library(leafem)
library(terra)
library(cmocean)


### Read in raster layers for latest date

# Model prediction
r <- rast("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/refs/heads/main/model_prediction/ROMS/rasters/pred_2024-11-24_leatherbackTurtle.tiff")

# Environmental predictors
eke <- rast("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/refs/heads/main/data_processing/ROMS/rasters/EKE_2024-11-24.tiff")
bv <- rast("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/refs/heads/main/data_processing/ROMS/rasters/bv_2024-11-24.tiff")
curl <- rast("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/refs/heads/main/data_processing/ROMS/rasters/curl_2024-11-24.tiff")
ild <- rast("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/refs/heads/main/data_processing/ROMS/rasters/ild_2024-11-24.tiff")
ssh <- rast("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/refs/heads/main/data_processing/ROMS/rasters/ssh_2024-11-24.tiff")
ssh_sd <- rast("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/refs/heads/main/data_processing/ROMS/rasters/ssh_sd_2024-11-24.tiff")
sst <- rast("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/refs/heads/main/data_processing/ROMS/rasters/sst_2024-11-24.tiff")
sst_sd <- rast("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/refs/heads/main/data_processing/ROMS/rasters/sst_sd_2024-11-24.tiff")


### Process rasters

# Merge all covars and crop to model extent
covars <- c(eke, bv, curl, ild, ssh, ssh_sd, sst, sst_sd)


# Define color palette for raster layer
pal <- colorNumeric("inferno", domain = values(r), na.color = "transparent")
eke.pal <- colorNumeric(cmocean("tempo")(256), domain = values(covars[[1]]), na.color = "transparent")
bv.pal <- colorNumeric(cmocean("deep")(256), domain = values(covars[[2]]), na.color = "transparent")
curl.pal <- colorNumeric(cmocean("curl")(256), domain = values(covars[[3]]), na.color = "transparent")
ild.pal <- colorNumeric(cmocean("dense")(256), domain = values(covars[[4]]), na.color = "transparent")
ssh.pal <- colorNumeric(cmocean("delta")(256), domain = values(covars[[5]]), na.color = "transparent")
ssh_sd.pal <- colorNumeric(cmocean("matter")(256), domain = values(covars[[6]]), na.color = "transparent")
sst.pal <- colorNumeric(cmocean("thermal")(256), domain = values(covars[[7]]), na.color = "transparent")
sst_sd.pal <- colorNumeric(cmocean("amp")(256), domain = values(covars[[8]]), na.color = "transparent")


navset_card_tab(
  nav_panel(title = "Model Prediction",
            card(full_screen = TRUE,
                 leaflet() |> 
                   addProviderTiles(provider = providers$CartoDB.DarkMatter, group = "CartoDB",
                                    options = providerTileOptions(zIndex = -10)) |> 
                   addProviderTiles(provider = providers$Esri.WorldImagery, group = "Satellite",
                                    options = providerTileOptions(zIndex = -10)) |> 
                   addProviderTiles(provider = providers$Esri.OceanBasemap, group = "Bathymetry",
                                    options = providerTileOptions(zIndex = -10)) |> 
                   addLayersControl(position = "topright",
                                    baseGroups = c("CartoDB","Satellite","Bathymetry"),
                                    overlayGroups = "HSI",
                                    options = layersControlOptions(collapsed = TRUE, autoZIndex = FALSE)) |> 
                   addRasterImage(r, colors = pal, opacity = 0.8, group = "HSI", layerId = "HSI") |> 
                   addImageQuery(r, layerId = "HSI") |>  #add raster  query
                   addLegend(title = "Habitat Suitability", position = "bottomright", pal = pal, values = values(r))
            )
  ),
  
  nav_panel(title = "Environ. Predictors",
            card(full_screen = TRUE,
                 leaflet() |> 
                   addProviderTiles(provider = providers$CartoDB.DarkMatter, group = "CartoDB",
                                    options = providerTileOptions(zIndex = -10)) |> 
                   addProviderTiles(provider = providers$Esri.WorldImagery, group = "Satellite",
                                    options = providerTileOptions(zIndex = -10)) |> 
                   addProviderTiles(provider = providers$Esri.OceanBasemap, group = "Bathymetry",
                                    options = providerTileOptions(zIndex = -10)) |> 
                   addLayersControl(position = "topright",
                                    baseGroups = c("CartoDB","Satellite","Bathymetry"),
                                    overlayGroups = c("log(EKE)","BV","Curl","ILD","SSH","SSH_SD","SST","SST_SD"),
                                    options = layersControlOptions(collapsed = TRUE, autoZIndex = FALSE)) |> 
                   
                   addRasterImage(covars[[1]], colors = eke.pal, opacity = 1, group = "log(EKE)", layerId = "log(EKE)") |> 
                   addImageQuery(covars[[1]], layerId = "log(EKE)") |>  #add raster  query
                   addLegend(title = "log(EKE)", position = "bottomright", pal = eke.pal, values = values(covars[[1]]),
                             group = "log(EKE)") |> 
                   
                   addRasterImage(covars[[2]], colors = bv.pal, opacity = 1, group = "BV", layerId = "BV") |> 
                   addImageQuery(covars[[2]], layerId = "BV") |>  #add raster  query
                   addLegend(title = "BV", position = "bottomright", pal = bv.pal, values = values(covars[[2]]),
                             group = "BV") |> 
                   
                   addRasterImage(covars[[3]], colors = curl.pal, opacity = 1, group = "Curl",
                                  layerId = "Curl") |> 
                   addImageQuery(covars[[3]], layerId = "Curl") |>  #add raster  query
                   addLegend(title = "Curl", position = "bottomright", pal = curl.pal,
                             values = values(covars[[3]]), group = "Curl") |> 
                   
                   addRasterImage(covars[[4]], colors = ild.pal, opacity = 1, group = "ILD", layerId = "ILD") |> 
                   addImageQuery(covars[[4]], layerId = "ILD") |>  #add raster  query
                   addLegend(title = "ILD", position = "bottomright", pal = ild.pal, values = values(covars[[4]]),
                             group = "ILD") |> 
                   
                   addRasterImage(covars[[5]], colors = ssh.pal, opacity = 1, group = "SSH",
                                  layerId = "SSH") |> 
                   addImageQuery(covars[[5]], layerId = "SSH") |>  #add raster  query
                   addLegend(title = "SSH", position = "bottomright", pal = ssh.pal,
                             values = values(covars[[5]]), group = "SSH") |> 
                   
                   addRasterImage(covars[[6]], colors = ssh_sd.pal, opacity = 1, group = "SSH_SD",
                                  layerId = "SSH_SD") |> 
                   addImageQuery(covars[[6]], layerId = "SSH_SD") |>  #add raster  query
                   addLegend(title = "SSH_SD", position = "bottomright", pal = ssh_sd.pal,
                             values = values(covars[[6]]), group = "SSH_SD") |> 
                   
                   addRasterImage(covars[[7]], colors = sst.pal, opacity = 1, group = "SST", layerId = "SST") |> 
                   addImageQuery(covars[[7]], layerId = "SST") |>  #add raster  query
                   addLegend(title = "SST", position = "bottomright", pal = sst.pal, values = values(covars[[7]]),
                             group = "SST") |> 
                   
                   addRasterImage(covars[[8]], colors = sst_sd.pal, opacity = 1, group = "SST_SD",
                                  layerId = "SST_SD") |> 
                   addImageQuery(covars[[8]], layerId = "SST_SD") |>  #add raster  query
                   addLegend(title = "SST_SD", position = "bottomright", pal = sst_sd.pal,
                             values = values(covars[[8]]), group = "SST_SD") |> 
                   
                   hideGroup(c("BV","Curl","ILD","SSH","SSH_SD","SST","SST_SD"))
            )
  )
)
```
:::



## Download Map Products and Raster Layers

### From website
<div>
  <label for="start-date">Start Date:</label>
  <input type="date" id="start-date" name="start-date" min="2024-11-08">
  
  <label for="end-date">End Date:</label>
  <input type="date" id="end-date" name="end-date" min="2024-11-08">
  
  <span id="start-date-range" style="font-size: 0.9em; color: #555; margin-left: 5px;"></span>

  <button onclick="filterAndDownload('png')" style="background-color: #002364; color: white">Download products</button>
  <button onclick="filterAndDownload('tiff')" style="background-color: #002364; color: white">Download rasters</button>
</div>

```{r}
# shiny::actionButton("prod_button", label = "Download products", onclick="filterAndDownload('png')")
# shiny::actionButton("rast_button", label = "Download rasters", onclick="filterAndDownload('tiff')")
```


<script>
async function fetchLatestDateFromGitHub() {
  const url = 'https://api.github.com/repos/joshcullen/CEG_operationalization/contents/model_prediction/ROMS/img';
  const response = await fetch(url);
  if (!response.ok) throw new Error('Failed to fetch filenames');
  const files = await response.json();

  const datePattern = /\d{4}-\d{2}-\d{2}/;
  let dates = files
    .map(file => file.name.match(datePattern))
    .filter(match => match)
    .map(match => match[0]);

  if (dates.length === 0) throw new Error("No valid dates found in filenames.");

  dates.sort(); // Ascending
  return {
    minDate: '2024-11-08', // Fixed known earliest date
    maxDate: dates[dates.length - 1]
  };
}

document.addEventListener("DOMContentLoaded", async () => {
  try {
    const { minDate, maxDate } = await fetchLatestDateFromGitHub();

    document.getElementById("start-date").min = minDate;
    document.getElementById("end-date").min = minDate;
    document.getElementById("start-date").max = maxDate;
    document.getElementById("end-date").max = maxDate;

    document.getElementById("start-date-range").textContent = `(Available: ${minDate} to ${maxDate})`;
    
  } catch (error) {
    console.error("Date range setup failed:", error);
  }
});
</script>



<div id="file-list" style="margin-top: 20px;"></div>


<!-- Spinner -->
<div id="spinner" style="display:none; margin-top:10px;">
  <div class="loader"></div>
  <p>Downloading files...</p>
</div>

<!-- JSZip -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<!-- Spinner CSS -->
<style>
.loader {
  border: 6px solid #f3f3f3;
  border-top: 6px solid #3498db;
  border-radius: 50%;
  width: 36px;
  height: 36px;
  animation: spin 1s linear infinite;
  margin: 10px auto;
}
@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
#spinner p {
  text-align: center;
  font-weight: bold;
  color: #333;
}
</style>



<script>
function extractDate(filename) {
  const match = filename.match(/(\d{4}-\d{2}-\d{2})/);
  return match ? new Date(match[1]) : null;
}

async function filterAndDownload(extension) {
  const startInput = document.getElementById('start-date');
  const endInput = document.getElementById('end-date');
  const startDate = new Date(startInput.value);
  const endDate = new Date(endInput.value);
  const listDiv = document.getElementById("file-list");
  const spinner = document.getElementById("spinner");

  if (isNaN(startDate) || isNaN(endDate)) {
    alert("Please select valid start and end dates.");
    return;
  }

  spinner.style.display = "block";
  listDiv.innerHTML = "";

  const folder = extension === "tiff"
    ? "model_prediction/ROMS/rasters"
    : "model_prediction/ROMS/img";

  const apiURL = `https://api.github.com/repos/joshcullen/CEG_operationalization/contents/${folder}`;

  try {
    const response = await fetch(apiURL);
    if (!response.ok) {
      throw new Error("Failed to fetch file list.");
    }

    const allFiles = await response.json();
    const matchingFiles = allFiles.filter(f =>
      f.name.toLowerCase().endsWith(`.${extension}`)
    );

    const filteredFiles = matchingFiles.filter(file => {
      const fileDate = extractDate(file.name);
      return fileDate && fileDate >= startDate && fileDate <= endDate;
    });

    if (filteredFiles.length === 0) {
      listDiv.innerHTML = `<p>No matching .${extension} files found in date range.</p>`;
      spinner.style.display = "none";
      return;
    }

    const zip = new JSZip();

    for (const file of filteredFiles) {
      const res = await fetch(file.download_url);
      const blob = await res.blob();
      const buffer = await blob.arrayBuffer();
      zip.file(file.name, buffer);
    }

    const content = await zip.generateAsync({ type: "blob" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(content);
    a.download = `Leatherback_ROMS_${extension.toUpperCase()}.zip`;
    a.click();

    listDiv.innerHTML = `<p>✅ File download complete.</p>`;
  } catch (error) {
    console.error(error);
    listDiv.innerHTML = `<p>❌ Error occurred: ${error.message}</p>`;
  } finally {
    spinner.style.display = "none";
  }
}

// Limit inputs to today
document.addEventListener("DOMContentLoaded", () => {
  const today = new Date().toISOString().split("T")[0];
  document.getElementById("start-date").max = today;
  document.getElementById("end-date").max = today;
});
</script>


### From GitHub

[Clone](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository) the repository: <https://github.com/joshcullen/CEG_operationalization>


### From R

```{r}
#| echo: true
#| eval: false

library(curl)
library(httr)
library(tidyverse)
library(glue)

download_files_git = function(save_dir, file_type, start_date, end_date){
  
  folder <- switch(file_type,
                   "raster" = "rasters",
                   "image" = "img")
  
  # Find files from repo folder
  prods <- httr::GET(glue("https://api.github.com/repos/joshcullen/CEG_operationalization/contents/model_prediction/ROMS/{folder}"))
  httr::stop_for_status(prods)  #check to make sure no errors w/ request (should return nothing to console if working properly)
  filelist <- unlist(lapply(content(prods), "[", "name"), use.names = F)
  prod_df <- data.frame(files = filelist,
                        date = gsub("^[A-Za-z]+\\_|\\.tiff$", "", filelist) |> 
                          as.Date()
  )
  
  # Filter files by date range
  prod_filt <- prod_df |> 
    filter(date >= as.Date(start_date),
           date <= as.Date(end_date)) |> 
    pull(files)
  
  git_url <- glue("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/main/model_prediction/ROMS/{folder}/{prod_filt}")
  file_dest <- glue("{save_dir}/{prod_filt}")
  
  curl::multi_download(urls = git_url, destfiles = file_dest)
}

# Download files
download_files_git(save_dir = "~/Downloads",
                   file_type = "raster",
                   start_date = "2024-11-08",
                   end_date = "2024-11-30")
download_files_git(save_dir = "~/Downloads",
                   file_type = "image",
                   start_date = "2024-11-08",
                   end_date = "2024-11-30")

```


