---
title: "Leatherback CMEMS model"
toc: false
editor: 
  markdown: 
    wrap: 72
execute:
  echo: false
include-in-header:
  text: <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
---

The most recent map products from the model are shown below, in addition
to an interactive map of the latest prediction.

```{r}
#| label: check-cmems
#| warning: false
#| include: false

library(readr)
library(dplyr)
library(purrr)
library(lubridate)

source("utils.R")

# Load metadata
meta_df <- read_csv("../metadata/model_metadata.csv") |> 
  filter(data_type == 'CMEMS',
         category != 'derived' | is.na(category)) |> 
  distinct(product, .keep_all = TRUE)

# Set today's date
get_date <- Sys.Date() - 1


# CMEMS status check
status <- sapply(meta_df$product,
                 \(x) check_cmems(path_copernicus_marine_toolbox = "C:\\Miniconda\\envs\\test\\bin\\copernicusmarine",
                                # \(x) check_cmems(path_copernicus_marine_toolbox = "/usr/share/miniconda/envs/test/bin/copernicusmarine",
                 # \(x) check_cmems(path_copernicus_marine_toolbox = "copernicusmarine",
                                                   productID = x, get_date = get_date))

# Create badge based on result of CMEMS status check
badge <- map2(.x = status,
              .y = meta_df$url,
             ~{ifelse(.x,
                      glue::glue("[![Static Badge](https://img.shields.io/badge/Status-Running-brightgreen?style=flat)]({.y})"),
                      glue::glue("[![Static Badge](https://img.shields.io/badge/Status-Down-red?style=flat)]({.y})")
             )}
)
```

**Status of environmental products from CMEMS:** 

```{r}
#| label: print-badges
#| results: asis

for (i in seq_along(badge)) {
  cat("- ")
  cat(paste0(names(badge)[i], ": "))
  cat(paste(badge[[i]], "\n"))
}
```
  

## Latest Map Products

```{r}
library(bslib)
library(htmltools)
library(httr)
library(glue)

bs_theme_dependencies(bs_theme(preset = "bootstrap")) |>
  lapply(function(x) {
    if (x$name == "bootstrap") {
      x$name <- "bootstrap-from-bslib"
    }
    x
  }) |>
  htmltools::tagList()


# Find latest products in GH repo
prods <- GET("https://api.github.com/repos/joshcullen/CEG_operationalization/contents/model_prediction/TopPredatorWatch/img")
stop_for_status(prods)
filelist <- unlist(lapply(content(prods), "[", "name"), use.names = F)
prod_dates <- data.frame(idx = seq_along(filelist),
                         date = gsub("^[A-Za-z]+\\_|\\.png$", "", filelist) |> 
                           as.Date()
                         )

latest <- prod_dates |> 
  arrange(desc(date))

# Create tabset panel for latest products
navset_card_tab(
  nav_panel(title = "Latest",
            img(src = glue("https://github.com/joshcullen/CEG_operationalization/blob/main/model_prediction/TopPredatorWatch/img/{filelist[latest$idx[1]]}?raw=true", width = "100%"))),
  nav_panel(title = "Latest - 1",
            img(src = glue("https://github.com/joshcullen/CEG_operationalization/blob/main/model_prediction/TopPredatorWatch/img/{filelist[latest$idx[2]]}?raw=true", width = "100%"))),
  nav_panel(title = "Latest - 2",
            img(src = glue("https://github.com/joshcullen/CEG_operationalization/blob/main/model_prediction/TopPredatorWatch/img/{filelist[latest$idx[3]]}?raw=true", width = "100%"))),
  nav_panel(title = "Latest - 3",
            img(src = glue("https://github.com/joshcullen/CEG_operationalization/blob/main/model_prediction/TopPredatorWatch/img/{filelist[latest$idx[4]]}?raw=true", width = "100%")))
  )
```




## Interactive Map

This example shows both model predictions and environmental covariates used to estimate the models. Change the date and selected variable to explore these relationships in more detail.

```{=html}
<iframe width="900" height="650" src="https://joshcullen.shinyapps.io/leatherback_cmems_model/"></iframe>
```




## Download Map Products and Raster Layers

### From website
<div>
  <label for="start-date">Start Date:</label>
  <input type="date" id="start-date" name="start-date" min="2024-11-08">
  
  <label for="end-date">End Date:</label>
  <input type="date" id="end-date" name="end-date" min="2024-11-08">
  
  <span id="start-date-range" style="font-size: 0.9em; color: #555; margin-left: 5px;"></span>

  <button onclick="filterAndDownload('png')" style="background-color: #002364; color: white">Download products</button>
  <button onclick="filterAndDownload('tiff')" style="background-color: #002364; color: white">Download rasters</button>
</div>



<script>
async function fetchLatestDateFromGitHub() {
  const url = 'https://api.github.com/repos/joshcullen/CEG_operationalization/contents/model_prediction/TopPredatorWatch/img';
  const response = await fetch(url);
  if (!response.ok) throw new Error('Failed to fetch filenames');
  const files = await response.json();

  const datePattern = /\d{4}-\d{2}-\d{2}/;
  let dates = files
    .map(file => file.name.match(datePattern))
    .filter(match => match)
    .map(match => match[0]);

  if (dates.length === 0) throw new Error("No valid dates found in filenames.");

  dates.sort(); // Ascending
  return {
    minDate: '2024-11-08', // Fixed known earliest date
    maxDate: dates[dates.length - 1]
  };
}

document.addEventListener("DOMContentLoaded", async () => {
  try {
    const { minDate, maxDate } = await fetchLatestDateFromGitHub();

    document.getElementById("start-date").min = minDate;
    document.getElementById("end-date").min = minDate;
    document.getElementById("start-date").max = maxDate;
    document.getElementById("end-date").max = maxDate;

    document.getElementById("start-date-range").textContent = `(Available: ${minDate} to ${maxDate})`;
    
  } catch (error) {
    console.error("Date range setup failed:", error);
  }
});
</script>


<div id="file-list" style="margin-top: 20px;"></div>


<!-- Spinner -->
<div id="spinner" style="display:none; margin-top:10px;">
  <div class="loader"></div>
  <p>Downloading files...</p>
</div>



<script>
function extractDate(filename) {
  const match = filename.match(/(\d{4}-\d{2}-\d{2})/);
  return match ? new Date(match[1]) : null;
}

async function filterAndDownload(extension) {
  const startInput = document.getElementById('start-date');
  const endInput = document.getElementById('end-date');
  const startDate = new Date(startInput.value);
  const endDate = new Date(endInput.value);
  const listDiv = document.getElementById("file-list");
  const spinner = document.getElementById("spinner");

  if (isNaN(startDate) || isNaN(endDate)) {
    alert("Please select valid start and end dates.");
    return;
  }

  spinner.style.display = "block";
  listDiv.innerHTML = "";

  const folder = extension === "tiff"
    ? "model_prediction/TopPredatorWatch/rasters"
    : "model_prediction/TopPredatorWatch/img";

  const apiURL = `https://api.github.com/repos/joshcullen/CEG_operationalization/contents/${folder}`;

  try {
    const response = await fetch(apiURL);
    if (!response.ok) {
      throw new Error("Failed to fetch file list.");
    }

    const allFiles = await response.json();
    const matchingFiles = allFiles.filter(f =>
      f.name.toLowerCase().endsWith(`.${extension}`)
    );

    const filteredFiles = matchingFiles.filter(file => {
      const fileDate = extractDate(file.name);
      return fileDate && fileDate >= startDate && fileDate <= endDate;
    });

    if (filteredFiles.length === 0) {
      listDiv.innerHTML = `<p>No matching .${extension} files found in date range.</p>`;
      spinner.style.display = "none";
      return;
    }

    const zip = new JSZip();

    for (const file of filteredFiles) {
      const res = await fetch(file.download_url);
      const blob = await res.blob();
      const buffer = await blob.arrayBuffer();
      zip.file(file.name, buffer);
    }

    const content = await zip.generateAsync({ type: "blob" });

    const a = document.createElement("a");
    a.href = URL.createObjectURL(content);
    a.download = `Leatherback_CMEMS_${extension.toUpperCase()}.zip`;
    a.click();

    listDiv.innerHTML = `<p>✅ File download complete.</p>`;
  } catch (error) {
    console.error(error);
    listDiv.innerHTML = `<p>❌ Error occurred: ${error.message}</p>`;
  } finally {
    spinner.style.display = "none";
  }
}

// Limit inputs to today
document.addEventListener("DOMContentLoaded", () => {
  const today = new Date().toISOString().split("T")[0];
  document.getElementById("start-date").max = today;
  document.getElementById("end-date").max = today;
});
</script>


### From GitHub

[Clone](https://docs.github.com/en/repositories/creating-and-managing-repositories/cloning-a-repository) the repository: <https://github.com/joshcullen/CEG_operationalization>


### From R

```{r}
#| echo: true
#| eval: false

library(curl)
library(httr)
library(tidyverse)
library(glue)

download_files_git = function(save_dir, file_type, start_date, end_date){
  
  folder <- switch(file_type,
                   "raster" = "rasters",
                   "image" = "img")
  
  # Find files from repo folder
  prods <- httr::GET(glue("https://api.github.com/repos/joshcullen/CEG_operationalization/contents/model_prediction/TopPredatorWatch/{folder}"))
  httr::stop_for_status(prods)  #check to make sure no errors w/ request (should return nothing to console if working properly)
  filelist <- unlist(lapply(content(prods), "[", "name"), use.names = F)
  prod_df <- data.frame(files = filelist,
                        date = gsub("^[A-Za-z]+\\_|\\.tiff$", "", filelist) |> 
                          as.Date()
  )
  
  # Filter files by date range
  prod_filt <- prod_df |> 
    filter(date >= as.Date(start_date),
           date <= as.Date(end_date)) |> 
    pull(files)
  
  git_url <- glue("https://raw.githubusercontent.com/joshcullen/CEG_operationalization/main/model_prediction/TopPredatorWatch/{folder}/{prod_filt}")
  file_dest <- glue("{save_dir}/{prod_filt}")
  
  curl::multi_download(urls = git_url, destfiles = file_dest)
}

# Download files
download_files_git(save_dir = "~/Downloads",
                   file_type = "raster",
                   start_date = "2025-06-25",
                   end_date = "2025-06-30")
download_files_git(save_dir = "~/Downloads",
                   file_type = "image",
                   start_date = "2025-06-25",
                   end_date = "2025-06-30")

```


